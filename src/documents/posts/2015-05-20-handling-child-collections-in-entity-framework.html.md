---
layout: post
title: "Handling child collections in Entity Framework"
description: "Configuring Entity Framework through fluent API sometimes is quite hard. In this article I am showing how to configure it to handle entity's child collections that those properly gets added and removed from collection."
category: [Entity Framework]
tags: [Entity Framework]
date: 2015-05-20
visible: true
---

<p class="lead">
Configuring Entity Framework through fluent API sometimes is quite hard. In this article I am showing how to configure it to handle entity's child collections that those properly gets added and removed from collection.
</p>

# Sample model

Here is sample model which to configure. It has root entity - _Order_ and collection of _OrderItems_.

    public class Order
    {
        public int Id { get; set; }

        public virtual ICollection<OrderItem> Items { get; set; }
    }

    public class OrderItem
    {
        public int Id { get; set; }
    }

And here is DB Context for this model.

    public class ModelDbContext : DbContext
    {
        public virtual DbSet<Order> Orders { get; set; }
    }

With this model in place I want an _Order_ to be responsible for child collection - when I save _Order_ also _OrderItems_ should be saved, when I remove item from collection and save _Order_, removed item should be deleted in database.

With default configuration it only adds items - creates new _OrderItem_ in DB and _links_ it to _Order_. But when you remove item from collection it just removes relationship between _Order_ and _OrderItem_. _OrderItem_ table in DB will still contain removed _OrderItem_, but with _NULL_ in _OrderId_ column.

# Solution

Solution is to define composite key for _OrderItem_ which would consist of _OrderItem's_ _Id_ and foreign key to _Order_ - _OrderId_. Now _OrderId_ column is automatically generated in database and we do not have it in our model. So first of all we have to add _OrderId_ to _OrderItem_.

    public class OrderItem
    {
        public int Id { get; set; }
        public int OrderId { get; set; }
    }

Now we have to configure composite key. It is easy with [Data Annotations](https://msdn.microsoft.com/en-us/data/jj591583.aspx#Composite), but I do not want my model to depend on _Entity Framework_ directly. So I will do it using fluent API.

Fluent API configuration has to be done in _DbConext's_ overriden method _OnModelCreating_.

    public class ModelDbContext : DbContext
    {
        public virtual DbSet<Order> Orders { get; set; }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
        }
    }

First of all configure foreign key relationship between _Order_ and _OrderItem_.

    modelBuilder.Entity<Order>()
        .HasMany(o => o.OrderItems)
        .WithOptional()
        .HasForeignKey(oi => oi.OrderId)

Next define composite key for _OrderItem_ using anonymous object. Also configure _Id_ column values to be auto-generated by database, because it does not generate those for composite keys.

    modelBuilder.Entity<OrderItem>()
        .HasKey(oi => new {oi.Id, oi.OrderId})
        .Property(oi => oi.Id)
        .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity);

And here is complete DB context.

    public class ModelDbContext : DbContext
    {
        public virtual DbSet<Order> Orders { get; set; }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Order>()
                .HasMany(o => o.OrderItems)
                .WithOptional()
                .HasForeignKey(oi => oi.OrderId);
            modelBuilder.Entity<OrderItem>()
                .HasKey(oi => new { oi.Id, oi.OrderId })
                .Property(oi => oi.Id)
                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity);
        }
    }

Now you can add/remove items from _Order_ and items will get persisted/deleted in database.

    // Adding new item
    using(var context = new ModelDbContext())
    {
        var order = context.Orders.Find(10);
        order.Items.Add(new OrderItem());
        context.SaveChanges();
    }

    // Removing item
    using (var context = new ModelDbContext())
    {
        var order = context.Orders.Find(10);
        var orderItem = order.Items.First();
        order.Items.Remove(orderItem);
        context.SaveChanges();
    }

    // Removing all items
    using (var context = new ModelDbContext())
    {
        var order = context.Orders.Find(10);
        order.Items.Clear();
        context.SaveChanges();
    }

**NOTE** When you want to remove all items from collection use _Clear_ method on collection. If instead you assign new collection, it will not remove items and leaves them.